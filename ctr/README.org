* 背景介绍
CTR(Click-through rate) 是用来表示用户点击一个特定链接的概率， 
通常被用来衡量一个在线广告系统的有效性。

当有多个广告位时，CTR 预估一般会作为排序的基准。
比如在百度的搜索广告系统，当用户输入一个带商业价值的搜索词（query）时，系统大体上会执行下列步骤：

1. 召回满足 query 的广告集合
2. 业务规则和相关性过滤
3. 根据拍卖机制和 CTR 排序
4. 展出

可以看到，CTR 在最终排序中起到了很重要的作用。

在业内，CTR 模型经历了如下的发展阶段：

- Logistic Regression(LR) + 特征工程
- LR + DNN 特征
- DNN + 特征工程

在发展早期时 LR 一统天下，但最近 DNN 模型由于其强大的学习能力和逐渐成熟的性能优化，
逐渐地接过 CTR 预估任务的大旗。

** LR vs DNN
下图展示了 LR 和一个 \(3x2\) 的 NN 模型的结构：

#+DOWNLOADED: file:/Users/superjom/project/paddle_models/ctr/img/LR vs DNN.jpg @ 2017-05-22 10:09:02
[[file:背景介绍/LR vs DNN_2017-05-22_10-09-02.jpg]]

LR 部分和蓝色箭头部分可以直接类比到 NN 中的结构，可以看到 LR 和 NN 有一些共通之处（比如权重累加），
但前者的模型复杂度在相同输入维度下比后者可能第很多（从某方面讲，模型越复杂，越有潜力学习到更复杂的信息）。

如果 LR 要达到匹敌 NN 的学习能力，必须增加输入的维度，也就是增加特征的数量（作为输入），
这也就是为何 LR 和大规模的特征工程必须绑定在一起的原因。

而 NN 模型具有自己学习新特征的能力，一定程度上能够提升特征使用的效率，
这使得 NN 模型在同样规模特征的情况下，更有可能达到更好的学习效果。

LR 对于 NN 模型的优势是对大规模稀疏特征的容纳能力，包括内存和计算量等，工业界都有非常成熟的优化方法。

本文后面的章节会演示如何使用 Paddle 编写一个结合两者优点的模型。

* 数据和任务抽象
我们可以将 `click` 作为学习目标，具体任务可以有以下几种方案：

1. 直接学习 click，0,1 作二元分类，或 pairwise rank（标签 1>0）
2. 统计每个广告的点击率，将同一个 query 下的广告两两组合，点击率高的>点击率低的

这里，我们直接使用第一种方法做分类任务。

我们使用 Kaggle 上 `Click-through rate prediction` 任务的数据集来演示模型。

各个字段内容如下：

- id: ad identifier
- click: 0/1 for non-click/click
- hour: format is YYMMDDHH, so 14091123 means 23:00 on Sept. 11, 2014 UTC.
- C1 -- anonymized categorical variable
- banner_pos
- site_id
- site_domain
- site_category
- app_id
- app_domain
- app_category
- device_id
- device_ip
- device_model
- device_type
- device_conn_type
- C14-C21 -- anonymized categorical variables

* 特征提取
下面我们会简单演示几种特征的提取方式。 

原始数据中的特征可以分为以下几类：

1. ID 类特征（稀疏，数量多）
   - id
   - site_id
   - app_id
   - device_id
  
2. 类别类特征（稀疏，但数量有限）
   - C1
   - site_category
   - device_type
   - C14-C21
  
3. 数值型特征
   - hour (可以转化成数值，也可以按小时为单位转化为类别）

** 类别类特征
类别类特征的提取方法有以下两种：

1. One-hot 表示作为特征
2. 类似词向量，用一个 Embedding Table 将每个类别映射到对应的向量

** ID 类特征
ID 类特征的特点是稀疏数据，但量比较大，直接使用 One-hot 表示时维度过大。

一般会作如下处理：

1. 确定表示的最大维度 N
2. newid = id % N
3. 用 newid 作为类别类特征使用

上面的方法尽管存在一定的碰撞概率，但能够处理任意数量的 ID 特征，并保留一定的效果[2]。

** 数值型特征
一般会做如下处理：

- 归一化，直接作为特征输入模型
- 用区间分割处理成类别类特征，稀疏化表示，模糊细微上的差别
 
** 处理方法实现
接下来我们演示具体方法的实现，为了简洁，我们只对一下几个特征作处理：

- site_category
- device_type
- id
- site_id
- hour


#+BEGIN_SRC python
  import sys

  class CategoryFeatureGenerator(object):
      '''
      Generator category features.
      '''
      def __init__(self):
          self.dic = {}
          self.counter = 0

      def register(self, key):
          if key not in self.dic:
              self.dic[key] = self.counter
              self.counter += 1

      def lookup(self, key):
          return self.dic[key]

#+END_SRC


* Wide & Deep Learning Model
谷歌在 16 年提出了 Wide & Deep Learning 的模型框架，用于融合 适合学习抽象特征的 DNN 和 适用于大规模系数特征的 LR 两种模型的优点。

** 模型简介
 Wide & Deep Learning Model 可以作为一种相对成熟的模型框架使用，
 在 CTR 预估的任务中工业界也有一定的应用，因此本文将演示使用此模型来完成 CTR 预估的任务。

 模型结构如下：

 [ pic ]

** 编写 LR 部分
** 编写 DNN 部分
** 两者融合

* 写在最后

- [1] https://en.wikipedia.org/wiki/Click-through_rate
- [2] Strategies for Training Large Scale Neural Network Language Models
- https://www.kaggle.com/c/avazu-ctr-prediction/data

